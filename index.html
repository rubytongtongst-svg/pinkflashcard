<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, viewport-fit=cover">
    
    <title>æˆ‘çš„å•è¯æœ¬</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="å•è¯æœ¬">
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 fill=%22%23ffc0cb%22/><text x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22central%22 text-anchor=%22middle%22 font-size=%2270%22>ğŸ“</text></svg>">

    <style>
        /* ğŸ¨ æ ¸å¿ƒæ ·å¼ */
        :root {
            --unified-pink: #ffc0cb; 
            --unified-pink-light: #fff5ee; 
            --bg-color: #fcfcfc; 
            --card-bg: #ffffff;
            --text-main: #333333; 
            --success-color: #66bb6a; 
            --warning-color: #ffa726; 
            --danger-color: #ef5350; 
            --info-color: #3b82f6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            
            /* ã€æ ¸å¿ƒæ”¹åŠ¨ã€‘ï¼šä½¿ç”¨ height: 100vh å’Œ overflow-y: hidden é»˜è®¤ç¦ç”¨æ»šåŠ¨ */
            height: 100vh; 
            overflow-y: hidden; 
            
            display: flex;
            flex-direction: column;
            align-items: center;
            
            margin: 0;
            /* é€‚é… iPhone åˆ˜æµ·å±çš„å®‰å…¨è·ç¦» */
            padding: 20px;
            padding-top: env(safe-area-inset-top, 20px);
            padding-bottom: env(safe-area-inset-bottom, 20px);
            /* ç¦æ­¢å¼¹æ€§æ»šåŠ¨æ•ˆæœ */
            overscroll-behavior: none; 
            box-sizing: border-box; 
        }

        h1 { margin-bottom: 20px; font-size: 1.6rem; color: var(--unified-pink); } 

        .scene {
            width: 100%;
            max-width: 400px;
            height: 260px;
            perspective: 1000px;
            /* ä¼˜åŒ–ï¼šå‡å°ä¸Šä¸‹ margin */
            margin: 10px 0; 
            cursor: pointer;
            /* ç¡®ä¿å…ƒç´ ä¸ä¼šè¢«é»˜è®¤æµè§ˆå™¨è¡Œä¸ºæ‹–æ‹½å½±å“ï¼Œä¼˜åŒ–æ»‘åŠ¨ä½“éªŒ */
            touch-action: pan-y;
        }

        .card {
            width: 100%;
            height: 100%;
            position: relative;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            border-radius: 16px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.05);
        }

        .card.is-flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: var(--card-bg);
            border-radius: 16px;
            padding: 20px;
            box-sizing: border-box;
            border: 8px solid var(--unified-pink); 
        }

        .card-face.front { font-size: 2.5rem; font-weight: 700; color: var(--text-main); } 
        .card-face.back { 
            transform: rotateY(180deg); 
            background-color: var(--unified-pink-light); 
            font-size: 1.8rem; 
            color: var(--text-main); 
        }

        .hint { font-size: 0.8rem; color: #94a3b8; margin-top: 10px; position: absolute; bottom: 15px;}

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            /* ç§»é™¤ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº®èƒŒæ™¯ */
            -webkit-tap-highlight-color: transparent;
        }
        
        /* ç¡®ä¿å£°éŸ³æŒ‰é’®çš„ padding å’Œå­—ä½“å¤§å°ä¸æ—è¾¹çš„ emoji æŒ‰é’®ä¸€è‡´ */
        #muteButton { 
            padding: 10px 15px; 
            font-size: 0.9rem;
        }

        .btn-nav { background-color: white; border: 1px solid #cbd5e1; color: #475569; }
        .btn-nav:hover { background-color: #f0f0f0; }

        .btn-check { background-color: var(--unified-pink); color: white; } 
        .btn-check:hover { background-color: #ffb1c0; } 
        
        .btn-new-deck, .btn-add { background-color: var(--unified-pink); color: white; }
        .btn-new-deck:hover, .btn-add:hover { background-color: #ffb1c0; } 

        .btn-del { background-color: #ffe0e0; color: var(--danger-color); }
        .btn-warn { background-color: #fff8e1; color: var(--warning-color); border: 1px solid #ffcc80; } 
        
        .btn-icon {
            padding: 5px 8px;
            margin-left: 4px;
            border-radius: 6px;
            font-size: 1rem;
        }
        .btn-icon-del { background-color: #ffe0e0; color: var(--danger-color); }
        .btn-icon-edit { background-color: #e0f2fe; color: var(--info-color); }
        .btn-icon-move { background-color: #f3e8ff; color: #9333ea; }

        .deck-controls {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 400px;
            justify-content: flex-end;
            margin-bottom: 15px; 
        }
        .deck-controls-editor {
            display: flex;
            gap: 10px;
            flex-wrap: wrap; 
            justify-content: flex-end;
            width: 100%;
            max-width: 400px;
            margin-top: 10px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
        }
        
        .typing-section {
            width: 100%;
            max-width: 400px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
            /* ä¼˜åŒ–ï¼šå‡å°ä¸‹æ–¹ margin */
            margin-bottom: 10px; 
        }

        #answerInput {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid var(--unified-pink); 
            border-radius: 6px;
            box-sizing: border-box; 
            /* ä¼˜åŒ–iOSè¾“å…¥ */
            -webkit-appearance: none; 
        }
        .typing-input-group {
            display: flex;
            gap: 10px;
        }
        .feedback {
            margin-top: 10px;
            font-weight: 600;
            height: 20px; 
            color: var(--danger-color);
        }
        
        input:focus {
            outline: none;
            border-color: var(--unified-pink); 
            box-shadow: 0 0 0 2px var(--unified-pink-light); 
        }

        .stats { margin-top: 10px; font-size: 0.9rem; color: #64748b; }
        
        .add-section input {
            width: 100%;
            padding: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            box-sizing: border-box; 
            margin-bottom: 10px;
            -webkit-appearance: none;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            /* ä¿®å¤iOSä¸Šæ¨¡æ€æ¡†æ»šåŠ¨ç©¿é€é—®é¢˜ */
            overscroll-behavior: contain;
        }
        .word-list-modal {
            background: white;
            padding: 20px;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            position: relative;
            display: flex;
            flex-direction: column;
            -webkit-overflow-scrolling: touch; /* iOSæµç•…æ»šåŠ¨ */
        }
        .word-list-modal h3 {
            border-bottom: 2px solid var(--unified-pink);
            padding-bottom: 10px;
            margin-top: 0;
        }
        
        .search-bar {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 1rem;
            -webkit-appearance: none;
        }

        .word-list-modal ul {
            list-style: none;
            padding: 0;
            flex-grow: 1;
            overflow-y: auto;
        }
        .word-list-modal li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px dotted #e2e8f0;
            font-size: 1rem;
        }
        .word-info {
            flex-grow: 1;
            padding-right: 10px;
        }
        .word-list-modal li strong {
            color: var(--unified-pink);
            margin-right: 5px;
        }
        .word-actions {
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }
        .close-btn {
            background: var(--text-main);
            color: white;
            padding: 8px;
            width: 100%;
            margin-top: 10px;
            border-radius: 6px;
        }
        
    </style>
</head>
<body>

    <h1>ğŸ“ æˆ‘çš„å•è¯æœ¬</h1>
    
    <div style="margin-bottom: 10px; width: 100%; max-width: 400px; text-align: left;">
        <label for="cardDeckSelect" style="display: block; font-size: 0.9rem; color: #64748b; margin-bottom: 5px;">é€‰æ‹©å¡ç»„/åˆ†ç±»:</label>
        <select id="cardDeckSelect" onchange="switchDeck()" style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #cbd5e1;">
            </select>
    </div>
    
    <div class="deck-controls deck-controls-editor">
        <button id="muteButton" class="btn-nav" onclick="toggleMute()" title="å¼€å¯/å…³é—­å£°éŸ³">ğŸ”Š</button>
        
        <div style="flex-grow: 1;"></div> 
        
        <button class="btn-nav" onclick="exportToPDF()" title="å¯¼å‡ºPDF">ğŸ–¨ï¸</button>

        <button id="unlockEditorButton" class="btn-check" onclick="unlockEditor()">ğŸ”‘ è§£é”ç¼–è¾‘</button>
        
        <button class="btn-nav editor-control" style="display: none;" onclick="viewAllWords()" title="æœç´¢/ç®¡ç†">ğŸ“–</button>
        <button class="btn-new-deck editor-control" style="display: none;" onclick="createNewDeck()">+ å¡ç»„</button>
        <button class="btn-warn editor-control" style="display: none;" onclick="deleteDeck()">- å¡ç»„</button>
    </div>
    
    <div class="stats">å½“å‰: <span id="currentIndex">0</span> / æ€»æ•°: <span id="totalCount">0</span></div>

    <div class="scene" onclick="flipCard()">
        <div class="card" id="flashcard">
            <div class="card-face front">
                <span id="displayFront">Loading...</span>
                <div class="hint">ç‚¹å‡»ç¿»çœ‹ç­”æ¡ˆ æˆ– å·¦å³æ»‘åŠ¨åˆ‡æ¢å¡ç‰‡</div>
            </div>
            <div class="card-face back">
                <span id="displayBack">...</span>
            </div>
        </div>
    </div>
    
    <div class="typing-section">
        <h3>âŒ¨ï¸ æ‰“å­—æ¨¡å¼ (ä¸­æ–‡ -> æ—¥è¯­)</h3>
        <div class="typing-input-group">
            <input type="text" id="answerInput" placeholder="è¯·è¾“å…¥æ—¥è¯­ç­”æ¡ˆ (æŒ‰ Enter æäº¤)" onkeydown="if(event.key === 'Enter') checkAnswer()">
            <button class="btn-check" onclick="checkAnswer()">æ£€æŸ¥ç­”æ¡ˆ</button>
        </div>
        <div id="feedback" class="feedback"></div>
    </div>


    <hr style="width: 100%; max-width: 400px; border: 0; border-top: 1px solid #e2e8f0; margin-bottom: 5px;">

    <div class="add-section editor-control" style="display: none;">
        <h3>æ·»åŠ åˆ°å¡ç»„ï¼š<span id="currentDeckDisplay" style="color: var(--unified-pink);">æˆ‘çš„è‡ªåˆ›è¯æ±‡</span></h3>
        <input type="text" id="inputFront" placeholder="æ­£é¢ (ä¸­æ–‡è¯æ±‡/æ„æ€)">
        <input type="text" id="inputBack" placeholder="èƒŒé¢ (æ—¥è¯­/å‡å/ç½—é©¬éŸ³ï¼Œå¦‚ï¼šå…ˆç”Ÿï¼ˆã›ã‚“ã›ã„ï¼‰)">
        <div style="margin-top: 15px;"> 
            <button class="btn-add" onclick="addNewCard()" style="width: 100%;">æ·»åŠ å¹¶ä¿å­˜åˆ°å½“å‰å¡ç»„</button>
        </div>
    </div>

    <div id="wordListModal" class="modal-overlay" style="display: none;">
        <div class="word-list-modal">
            <h3 id="wordListTitle">å•è¯è¡¨</h3>
            <input type="text" id="wordSearchInput" class="search-bar" placeholder="ğŸ” è¾“å…¥ä¸­æ–‡æˆ–æ—¥è¯­æŸ¥æ‰¾..." onkeyup="filterWordList()">
            <div id="moveActions" style="margin-bottom: 15px; padding: 10px; border: 1px solid var(--unified-pink-light); border-radius: 6px; display: none; background: #fff;">
                <label for="targetDeckSelect" style="font-size: 0.9rem; color: #64748b;">é€‰æ‹©ç›®æ ‡å¡ç»„:</label>
                <select id="targetDeckSelect" style="padding: 8px; border-radius: 6px; border: 1px solid #cbd5e1; width: 60%; margin-right: 10px;"></select>
                <button class="btn-check btn-modal-action" onclick="moveWordToDeck(this)">ğŸš€ ç§»åŠ¨</button>
            </div>
            <ul id="wordListContent"></ul>
            <button class="close-btn" onclick="closeWordList()">å…³é—­åˆ—è¡¨</button>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";

        // è¯·æ³¨æ„ï¼šè¿™é‡Œçš„ Firebase é…ç½®æ˜¯ç¤ºä¾‹ï¼Œå¦‚æœæ‚¨æœ‰è‡ªå·±çš„é¡¹ç›®ï¼Œè¯·æ›¿æ¢æˆæ‚¨è‡ªå·±çš„é…ç½®ï¼
        const firebaseConfig = {
            apiKey: "AIzaSyDRh1wj0UPt60ZDmVOKLc_qZ1FYE6J7TC",
            authDomain: "my-flashcard-sync.firebaseapp.com",
            projectId: "my-flashcard-sync",
            storageBucket: "my-flashcard-sync.appspot.com",
            messagingSenderId: "458534614208",
            appId: "1:458534614208:web:349f3c7a68cfed6f346925"
        };
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const USER_DOC_ID = 'RubyUserFlashcards'; 
        const USER_COLLECTION = 'user-decks'; 

        const initialDecks = {
            'æˆ‘çš„è‡ªåˆ›è¯æ±‡': [
                { front: "æ—¥è¯­", back: "æ—¥æœ¬èªï¼ˆã«ã»ã‚“ã”ï¼‰" }, 
                { front: "è€å¸ˆ", back: "å…ˆç”Ÿï¼ˆã›ã‚“ã›ã„ï¼‰" },
                { front: "æˆ‘", back: "ç§ï¼ˆã‚ãŸã—ï¼‰" }
            ],
            'JLPT N5 åŸºç¡€': [
                { front: "æ—©ä¸Šå¥½", back: "ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™" },
                { front: "è°¢è°¢", back: "ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™" },
                { front: "äºº", back: "äººï¼ˆã²ã¨ï¼‰" }
            ]
        };

        let allDecks = {}; 
        let currentDeckName = 'æˆ‘çš„è‡ªåˆ›è¯æ±‡'; 
        let cards = []; 
        let currentIndex = 0;
        let isMuted = true; 
        let japaneseVoice = null; 
        
        const EDITOR_PASSWORD = "Japan"; 
        let isEditorUnlocked = false; 

        const cardElement = document.getElementById('flashcard');
        const frontElement = document.getElementById('displayFront');
        const backElement = document.getElementById('displayBack');
        const deckSelect = document.getElementById('cardDeckSelect');
        const deckDisplay = document.getElementById('currentDeckDisplay');
        const answerInput = document.getElementById('answerInput');
        const feedbackElement = document.getElementById('feedback');
        
        function initializeSpeech() {
            if (!('speechSynthesis' in window)) return;
            const setVoice = () => {
                const voices = speechSynthesis.getVoices();
                japaneseVoice = voices.find(voice => 
                    voice.lang === 'ja-JP' && 
                    (voice.name.includes('Google') || voice.name.includes('Kyoko') || voice.name.includes('Haruka'))
                );
                if (!japaneseVoice) japaneseVoice = voices.find(voice => voice.lang === 'ja-JP');
                if (japaneseVoice) console.log("å·²åŠ è½½æ—¥è¯­å£°æº:", japaneseVoice.name);
                speechSynthesis.onvoiceschanged = null; 
            };
            if (speechSynthesis.getVoices().length) setVoice();
            else speechSynthesis.onvoiceschanged = setVoice;
        }

        function updateMuteButtonUI() {
            const button = document.getElementById('muteButton');
            if (isMuted) {
                // ä»…æ˜¾ç¤ºå¼€å¯å£°éŸ³çš„ Emoji
                button.innerHTML = 'ğŸ”Š';
                button.className = 'btn-nav'; 
            } else {
                // ä»…æ˜¾ç¤ºé™éŸ³çš„ Emoji
                button.innerHTML = 'ğŸ”‡';
                button.className = 'btn-warn'; 
            }
        }

        function updateEditorUI() {
            const isLocked = !isEditorUnlocked;
            document.querySelectorAll('.editor-control').forEach(el => el.style.display = isLocked ? 'none' : '');
            const unlockButton = document.getElementById('unlockEditorButton');
            if(unlockButton) unlockButton.style.display = isLocked ? 'block' : 'none'; // ä½¿ç”¨ 'block' æ¥ç¡®ä¿æŒ‰é’®åœ¨è§£é”æ—¶éšè—

            // ç¡®ä¿åœ¨ updateEditorUI è¿è¡Œæ—¶ä¹ŸåŒæ­¥ body æ ·å¼ï¼Œä»¥é˜²ä¸‡ä¸€
            const body = document.body;
            if (isLocked) {
                body.style.overflowY = 'hidden';
                body.style.height = '100vh';
            } else {
                body.style.overflowY = 'auto';
                body.style.height = 'auto';
            }
        }
        
        // ã€æ ¸å¿ƒä¿®æ”¹ã€‘åŠ¨æ€æ§åˆ¶ body æ»šåŠ¨
        window.unlockEditor = function() {
            if (isEditorUnlocked) { 
                // å¦‚æœå·²ç»è§£é”ï¼Œä½†ç”¨æˆ·å†æ¬¡ç‚¹å‡»ï¼Œè¯¢é—®æ˜¯å¦é”å®š
                if (confirm("ç¼–è¾‘åŠŸèƒ½å·²è§£é”ã€‚è¦é”å®šç¼–è¾‘å¹¶ç¦ç”¨æ»šåŠ¨å—ï¼Ÿ")) {
                    isEditorUnlocked = false;
                } else {
                    return; // ä¿æŒè§£é”çŠ¶æ€
                }
            } else {
                const inputPassword = prompt("è¯·è¾“å…¥ç¼–è¾‘å¯†ç ä»¥è§£é”åŠŸèƒ½ï¼š");
                if (inputPassword === EDITOR_PASSWORD) {
                    isEditorUnlocked = true;
                    alert("ç¼–è¾‘åŠŸèƒ½å·²æˆåŠŸè§£é”ï¼ç°åœ¨æ‚¨å¯ä»¥å‘ä¸‹æ»šåŠ¨æ·»åŠ å•è¯ã€‚");
                } else if (inputPassword !== null && inputPassword !== "") {
                    alert("å¯†ç é”™è¯¯ï¼Œç¼–è¾‘åŠŸèƒ½æœªè§£é”ã€‚");
                }
            }

            // ã€æ ¸å¿ƒé€»è¾‘ã€‘ï¼šæ ¹æ®è§£é”çŠ¶æ€åˆ‡æ¢ body æ»šåŠ¨
            const body = document.body;
            if (isEditorUnlocked) {
                // è§£é” -> å…è®¸æ»šåŠ¨ï¼Œä»¥ä¾¿æŸ¥çœ‹æ·»åŠ åŒºåŸŸ
                body.style.overflowY = 'auto'; 
                body.style.height = 'auto'; // å…è®¸ body é«˜åº¦éšå†…å®¹å»¶ä¼¸
            } else {
                // é”å®š -> ç¦æ­¢æ»šåŠ¨ï¼Œä¿æŒå¡ç‰‡åº”ç”¨ä½“éªŒ
                body.style.overflowY = 'hidden';
                body.style.height = '100vh'; // å¼ºåˆ¶ body ä¿æŒåœ¨è§†å£é«˜åº¦
            }

            updateEditorUI();
        }

        async function saveDecks() {
            try {
                const docData = { decks: allDecks, currentDeck: currentDeckName };
                await setDoc(doc(db, USER_COLLECTION, USER_DOC_ID), docData);
            } catch (e) {
                console.error("ä¿å­˜å¤±è´¥:", e);
                document.getElementById('feedback').innerText = "âŒ è­¦å‘Šï¼šåŒæ­¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œï¼";
            }
            updateUI();
        }

        async function loadDecks() {
            try {
                const docRef = doc(db, USER_COLLECTION, USER_DOC_ID);
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    allDecks = data.decks || initialDecks;
                    currentDeckName = data.currentDeck || Object.keys(allDecks)[0];
                    currentIndex = 0; 
                } else {
                    allDecks = initialDecks;
                    currentDeckName = Object.keys(allDecks)[0];
                    await saveDecks(); 
                }
            } catch (e) {
                allDecks = initialDecks;
                currentDeckName = Object.keys(allDecks)[0];
                alert("â— é”™è¯¯ï¼šäº‘è¿æ¥å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°æ•°æ®ã€‚");
            }
            updateMuteButtonUI();
            populateDeckSelect();
            switchDeck(currentDeckName, false); 
            updateEditorUI(); 
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        window.updateUI = function() {
            const displayCards = cards.length === 0 ? [{front: `å¡ç»„ã€${currentDeckName}ã€‘`, back: "å¡ç‰‡ä¸ºç©ºï¼Œè¯·åœ¨ä¸‹æ–¹æ·»åŠ "}] : cards;
            currentIndex = Math.max(0, Math.min(currentIndex, cards.length - 1));
            
            document.getElementById('totalCount').innerText = cards.length;
            document.getElementById('currentIndex').innerText = cards.length === 0 ? 0 : currentIndex + 1;
            deckDisplay.innerText = currentDeckName; 
            feedbackElement.innerText = ''; 
            answerInput.value = ''; 

            if (cardElement.classList.contains('is-flipped')) {
                cardElement.classList.remove('is-flipped');
                setTimeout(() => setCardText(displayCards), 250);
            } else {
                setCardText(displayCards);
            }
            populateDeckSelect(); 
        }

        function setCardText(displayCards) {
            const currentCard = displayCards[Math.min(currentIndex, displayCards.length - 1)];
            frontElement.innerText = currentCard.front;
            backElement.innerText = currentCard.back; 
        }

        window.flipCard = function() {
            cardElement.classList.toggle('is-flipped');
            if(cardElement.classList.contains('is-flipped')) {
                const card = cards.length > 0 ? cards[currentIndex] : null;
                if(card) {
                    const backText = card.back.trim();
                    const firstParenIndex = backText.search(/[ï¼ˆ(]/);
                    let textToRead = firstParenIndex > 0 ? backText.substring(0, firstParenIndex).trim() : backText;
                    readText(textToRead, 'ja-JP'); 
                }
            } 
        }
        
        // ====== å¯¼å‡º PDF åŠŸèƒ½ (ç°åœ¨ä»»ä½•äººéƒ½å¯ä»¥ä½¿ç”¨) ======
        window.exportToPDF = function() {
            // 1. å®šä¹‰æ‰“å°é¡µé¢çš„æ ·å¼ï¼Œå¹¶æ–°å¢æŒ‰é’®çš„CSS
            let printStyle = `<style>
                /* PDF æŠ¥å‘Šçš„åŸºç¡€æ ·å¼ */
                body{font-family:sans-serif;padding:20px}
                h1{text-align:center; color: #ffc0cb;}
                h2{border-bottom:2px solid #ffc0cb;margin-top:30px}
                table{width:100%;border-collapse:collapse; margin-top: 15px;}
                th,td{border:1px solid #ddd;padding:8px}
                th{background:#fff0f5}
                tr:nth-child(even){background:#f9f9f9}
                
                /* é¢„è§ˆç•Œé¢æŒ‰é’®æ ·å¼ */
                .header-controls { 
                    text-align: center; 
                    padding: 15px; 
                    margin-bottom: 20px;
                    border-bottom: 1px solid #e0e0e0;
                }
                .control-button { 
                    padding: 12px 30px; 
                    border: none; 
                    border-radius: 8px; 
                    cursor: pointer; 
                    font-size: 1rem;
                    font-weight: 600;
                    margin: 5px;
                    transition: background-color 0.2s;
                }
                .close-button { 
                    background-color: #f44336; /* çº¢è‰² */
                    color: white; 
                }
                .print-button { 
                    background-color: #2196F3; /* è“è‰² */
                    color: white; 
                }
                /* éšè—æŒ‰é’®ï¼šå½“æµè§ˆå™¨è¿›å…¥å®é™…æ‰“å°æ¨¡å¼æ—¶ï¼Œéšè—è¿™äº›æ§ä»¶ */
                @media print {
                    .header-controls { display: none !important; }
                }
            </style>`;

            // 2. å®šä¹‰æ‰‹åŠ¨å…³é—­å’Œæ‰“å°æŒ‰é’®çš„ HTML
            let controlsHTML = `
                <div class="header-controls">
                    <button class="control-button close-button" onclick="window.close()">âŒ å…³é—­é¢„è§ˆ/è¿”å›å•è¯æœ¬</button>
                    <button class="control-button print-button" onclick="window.print()">ğŸ–¨ï¸ æ‰“å°/ä¿å­˜ PDF</button>
                </div>`;

            // 3. æ‹¼æ¥æ‰“å°é¡µé¢çš„ä¸»ä½“å†…å®¹
            let printContent = `<html><head><title>å•è¯è¡¨</title>${printStyle}</head><body>`;
            printContent += controlsHTML; // åœ¨é¡¶éƒ¨æ·»åŠ æŒ‰é’®

            printContent += `<h1>ğŸ“š æˆ‘çš„å•è¯æœ¬</h1>`;
            
            Object.keys(allDecks).sort().forEach(deckName => {
                if (deckName === 'è¯·æ·»åŠ æ–°å¡ç»„') return;
                const deckCards = allDecks[deckName];
                if (deckCards.length === 0) return;
                printContent += `<h2>${deckName} (${deckCards.length})</h2><table><thead><tr><th width="40%">ä¸­æ–‡</th><th>æ—¥æ–‡</th></tr></thead><tbody>`;
                deckCards.forEach(card => { printContent += `<tr><td>${card.front}</td><td>${card.back}</td></tr>`; });
                printContent += `</tbody></table>`;
            });
            
            printContent += `</body></html>`;

            // 4. æ‰“å¼€æ–°çª—å£å¹¶å†™å…¥å†…å®¹
            const printWindow = window.open('', '_blank');
            printWindow.document.write(printContent);
            printWindow.document.close();

            // 5. ç§»é™¤è‡ªåŠ¨ print() å’Œè‡ªåŠ¨ close()ã€‚è®©ç”¨æˆ·æ‰‹åŠ¨ç‚¹å‡»æŒ‰é’®æ§åˆ¶ã€‚
        }

        // åˆ é™¤å¡ç‰‡åŠŸèƒ½ï¼Œç°åœ¨åªèƒ½åœ¨ç®¡ç†ç•Œé¢ä½¿ç”¨
        window.deleteCurrentCard = function() {
            // æ­¤åŠŸèƒ½æŒ‰é’®å·²ç§»é™¤ï¼Œä½†å‡½æ•°ä¿ç•™ï¼Œä»¥é˜²ä¸‡ä¸€
            if (!isEditorUnlocked) return alert("è¯·å…ˆè§£é”ç¼–è¾‘ã€‚");
            if (cards.length === 0) return;
            if(confirm(`ç¡®å®šä»ã€${currentDeckName}ã€‘ä¸­åˆ é™¤å¡ç‰‡ï¼š${cards[currentIndex].front} å—ï¼Ÿ`)) {
                const cardToDelete = cards[currentIndex];
                const deck = allDecks[currentDeckName];
                const indexInDeck = deck.findIndex(c => c.front === cardToDelete.front && c.back === cardToDelete.back);
                if (indexInDeck > -1) {
                    deck.splice(indexInDeck, 1);
                    cards.splice(currentIndex, 1); // ä»å½“å‰åˆ—è¡¨ä¸­åˆ é™¤
                    currentIndex = Math.max(0, Math.min(currentIndex, cards.length - 1));
                    saveDecks(); 
                    updateUI(); 
                }
            }
        }


        function renderWordList(filterText = '') {
            const listContent = document.getElementById('wordListContent');
            listContent.innerHTML = '';
            let displayList = [];
            if (currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') {
                Object.keys(allDecks).forEach(deck => {
                    if (deck !== 'è¯·æ·»åŠ æ–°å¡ç»„') {
                        displayList = displayList.concat(allDecks[deck].map(c => ({...c, sourceDeck: deck})));
                    }
                });
            } else {
                displayList = allDecks[currentDeckName] ? allDecks[currentDeckName].map(c => ({...c, sourceDeck: currentDeckName})) : [];
            }

            if (filterText) {
                const lowerFilter = filterText.toLowerCase();
                displayList = displayList.filter(c => 
                    c.front.toLowerCase().includes(lowerFilter) || 
                    c.back.toLowerCase().includes(lowerFilter)
                );
            }

            if (displayList.length === 0) {
                listContent.innerHTML = '<li style="text-align:center; color:#999;">æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„å•è¯</li>';
                return;
            }

            displayList.forEach((card) => {
                const li = document.createElement('li');
                const info = document.createElement('div');
                info.className = 'word-info';
                const deckInfo = currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)' ? `<span style="font-size:0.8em; color:#999; display:block;">[${card.sourceDeck}]</span>` : '';
                info.innerHTML = `${deckInfo}<strong>${card.front}</strong> ${card.back}`;
                
                const actions = document.createElement('div');
                actions.className = 'word-actions';
                const moveBtn = document.createElement('button');
                moveBtn.className = 'btn-icon btn-icon-move';
                moveBtn.innerText = 'â¡ï¸';
                moveBtn.onclick = () => quickMoveWord(card.front, card.back, card.sourceDeck);
                const editBtn = document.createElement('button');
                editBtn.className = 'btn-icon btn-icon-edit';
                editBtn.innerText = 'âœï¸';
                editBtn.onclick = () => editWord(card.front, card.back, card.sourceDeck);
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn-icon btn-icon-del';
                deleteBtn.innerText = 'âŒ';
                deleteBtn.onclick = () => quickDeleteWord(card.front, card.back, card.sourceDeck);
                
                actions.appendChild(moveBtn);
                actions.appendChild(editBtn);
                actions.appendChild(deleteBtn);
                li.appendChild(info);
                li.appendChild(actions);
                listContent.appendChild(li);
            });
        }

        window.filterWordList = function() {
            const input = document.getElementById('wordSearchInput');
            renderWordList(input.value);
        }

        window.viewAllWords = function() {
            if (!isEditorUnlocked) return alert("è¯·å…ˆè§£é”ç¼–è¾‘ã€‚");
            document.getElementById('wordListTitle').innerText = `ğŸ“– ${currentDeckName} - å•è¯è¡¨`;
            document.getElementById('wordSearchInput').value = ''; 
            renderWordList();
            document.getElementById('wordListModal').style.display = 'flex';
        }

        window.closeWordList = function() {
            document.getElementById('wordListModal').style.display = 'none';
        }

        window.quickDeleteWord = async function(front, back, deckName) {
            if(!confirm(`åˆ é™¤ã€${front}ã€‘?`)) return;
            const deck = allDecks[deckName];
            const idx = deck.findIndex(c => c.front === front && c.back === back);
            if (idx > -1) {
                deck.splice(idx, 1);
                await saveDecks();
                renderWordList(document.getElementById('wordSearchInput').value); 
                if (currentDeckName === deckName || currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') switchDeck(currentDeckName, false);
            }
        }

        window.editWord = async function(front, back, deckName) {
            const newFront = prompt("ä¿®æ”¹ä¸­æ–‡/æ­£é¢:", front);
            if (newFront === null) return;
            const newBack = prompt("ä¿®æ”¹æ—¥æ–‡/èƒŒé¢:", back);
            if (newBack === null) return;
            if (!newFront || !newBack) return alert("å†…å®¹ä¸èƒ½ä¸ºç©º");

            const deck = allDecks[deckName];
            const idx = deck.findIndex(c => c.front === front && c.back === back);
            if (idx > -1) {
                deck[idx] = { front: newFront, back: newBack };
                await saveDecks();
                renderWordList(document.getElementById('wordSearchInput').value);
                if (currentDeckName === deckName || currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') switchDeck(currentDeckName, false);
            }
        }

        window.quickMoveWord = async function(front, back, fromDeckName) {
            const availableDecks = Object.keys(allDecks).filter(d => d !== 'è¯·æ·»åŠ æ–°å¡ç»„' && d !== fromDeckName).sort();
            if (availableDecks.length === 0) return alert("æ²¡æœ‰å…¶ä»–å¡ç»„å¯ç§»åŠ¨ã€‚");

            let promptMsg = `è¯·è¾“å…¥ç›®æ ‡å¡ç»„çš„ã€ç¼–å·ã€‘:\n`;
            availableDecks.forEach((name, i) => promptMsg += `${i+1}. ${name}\n`);
            
            const selection = prompt(promptMsg);
            if (!selection) return;
            const targetIndex = parseInt(selection) - 1;
            if (isNaN(targetIndex) || targetIndex < 0 || targetIndex >= availableDecks.length) return alert("ç¼–å·æ— æ•ˆã€‚");
            
            const targetDeckName = availableDecks[targetIndex];
            const sourceDeck = allDecks[fromDeckName];
            const idx = sourceDeck.findIndex(c => c.front === front && c.back === back);
            if (idx > -1) {
                const card = sourceDeck.splice(idx, 1)[0]; 
                allDecks[targetDeckName].push(card); 
                await saveDecks();
                alert(`å·²ç§»åŠ¨åˆ°ã€${targetDeckName}ã€‘`);
                renderWordList(document.getElementById('wordSearchInput').value);
                if (currentDeckName === fromDeckName || currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') switchDeck(currentDeckName, false);
            }
        }

        window.createNewDeck = async function() {
            if (!isEditorUnlocked) return alert("è¯·å…ˆè§£é”ç¼–è¾‘ã€‚");
            const newName = prompt("è¯·è¾“å…¥æ–°å¡ç»„åç§°:");
            if (newName && newName.trim() && !allDecks[newName.trim()]) {
                allDecks[newName.trim()] = [];
                currentDeckName = newName.trim();
                populateDeckSelect();
                await saveDecks();
                switchDeck(currentDeckName, false);
            } else if (newName) alert("æ— æ•ˆæˆ–å·²å­˜åœ¨ï¼");
        }

        window.deleteDeck = async function() {
            if (!isEditorUnlocked) return alert("è¯·å…ˆè§£é”ç¼–è¾‘ã€‚");
            if(currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') return alert("è¯·å…ˆåˆ‡æ¢åˆ°å…·ä½“å¡ç»„ã€‚");
            if (Object.keys(allDecks).length <= 1) return alert("ä¸èƒ½åˆ é™¤æœ€åä¸€ä¸ªå¡ç»„ã€‚");
            
            if (confirm(`âš ï¸ ç¡®å®šåˆ é™¤å¡ç»„ã€${currentDeckName}ã€‘å—ï¼Ÿ`)) {
                delete allDecks[currentDeckName];
                currentDeckName = Object.keys(allDecks).find(n => n !== 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') || Object.keys(allDecks)[0];
                await saveDecks();
                populateDeckSelect(); 
                switchDeck(currentDeckName, false);
            }
        }
        
        window.nextCard = async function() {
            if (cards.length === 0) return; 
            if (currentIndex < cards.length - 1) currentIndex++;
            else {
                currentIndex = 0; 
                if(currentDeckName !== 'è¯·æ·»åŠ æ–°å¡ç»„') { switchDeck(currentDeckName, false); return; }
            }
            updateUI();
        }

        window.prevCard = async function() {
            if (cards.length === 0) return; 
            if (currentIndex > 0) currentIndex--;
            else {
                currentIndex = cards.length - 1; 
                if(currentDeckName !== 'è¯·æ·»åŠ æ–°å¡ç»„') { switchDeck(currentDeckName, false); return; }
            }
            updateUI();
        }
        
        function populateDeckSelect() {
            deckSelect.innerHTML = '';
            const deckNames = Object.keys(allDecks).sort();
            if (deckNames.length === 0) { deckNames.push("è¯·æ·»åŠ æ–°å¡ç»„"); allDecks["è¯·æ·»åŠ æ–°å¡ç»„"] = []; }
            
            const totalCount = deckNames.reduce((sum, name) => name!=='è¯·æ·»åŠ æ–°å¡ç»„' ? sum + allDecks[name].length : sum, 0);
            const allOption = document.createElement('option');
            allOption.value = 'æ‰€æœ‰å¡ç‰‡ (éšæœº)';
            allOption.innerText = `æ‰€æœ‰å¡ç‰‡ (æ€»æ•°: ${totalCount})`;
            deckSelect.appendChild(allOption);

            deckNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.innerText = `${name} (${allDecks[name].length})`;
                deckSelect.appendChild(option);
            });
            deckSelect.value = currentDeckName;
        }
        
        window.switchDeck = async function(deckName = deckSelect.value, shouldSave = true) {
            currentDeckName = deckName;
            if (currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') {
                let allCards = [];
                Object.keys(allDecks).forEach(deck => {
                    if (deck !== 'è¯·æ·»åŠ æ–°å¡ç»„') allCards = allCards.concat(allDecks[deck]);
                });
                cards = allCards;
            } else {
                cards = allDecks[currentDeckName] || [];
            }
            
            if (cards.length > 0) cards = shuffleArray([...cards]); 
            currentIndex = 0; 
            
            if(cards.length === 0) cards = [{front: `å¡ç»„ã€${currentDeckName}ã€‘`, back: "å¡ç‰‡ä¸ºç©ºï¼Œè¯·åœ¨ä¸‹æ–¹æ·»åŠ "}];
            
            if (shouldSave && currentDeckName !== 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') await saveDecks(); 
            else updateUI();
        }

        window.toggleMute = function() {
            isMuted = !isMuted;
            updateMuteButtonUI();
        }
        
        function readText(text, lang) {
            if (lang === 'zh-CN' || isMuted || !('speechSynthesis' in window)) return;
            if (lang === 'ja-JP') {
                speechSynthesis.cancel(); 
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = lang; 
                if (japaneseVoice) utterance.voice = japaneseVoice;
                else utterance.rate = 0.8;
                speechSynthesis.speak(utterance);
            }
        }
        
        window.checkAnswer = function() {
            if (cards.length === 0 || cards[currentIndex].front.includes('å¡ç»„ã€')) {
                feedbackElement.innerText = "è¯·å…ˆæ·»åŠ å¡ç‰‡ï¼"; return;
            }
            const card = cards[currentIndex];
            const actual = answerInput.value.toLowerCase().trim();
            const backContent = card.back.toLowerCase().trim(); 
            let acceptableAnswers = [];
            const regex = /(.+)\s*[ï¼ˆ(](\S+)[)ï¼‰]/; 
            const match = backContent.match(regex);
            
            if (match) {
                acceptableAnswers.push(match[1].trim());
                acceptableAnswers.push(match[2].trim());
            } else {
                acceptableAnswers.push(backContent);
            }

            if (acceptableAnswers.includes(actual)) {
                feedbackElement.innerText = "ğŸ‰ æ­£ç¡®ï¼";
                feedbackElement.style.color = 'var(--success-color)';
                setTimeout(() => { window.nextCard(); }, 700);
            } else {
                feedbackElement.innerText = `âŒ é”™è¯¯ã€‚ç­”æ¡ˆå¯ä»¥æ˜¯: ${acceptableAnswers.join(' æˆ– ')}ã€‚`;
                feedbackElement.style.color = 'var(--danger-color)';
            }
        }
        
        // ====== æ‰‹åŠ¿æ“ä½œé€»è¾‘ (æ›¿æ¢ ä¸Šä¸€ä¸ª/ä¸‹ä¸€ä¸ª æŒ‰é’®) ======
        const cardScene = document.querySelector('.scene');
        let touchStartX = 0;
        const SWIPE_THRESHOLD = 80; // æ»‘åŠ¨æœ€å°è·ç¦»ï¼ˆåƒç´ ï¼‰ï¼Œé˜²æ­¢è¯¯è§¦

        cardScene.addEventListener('touchstart', (e) => {
            // è®°å½•è§¦æ‘¸å¼€å§‹çš„Xåæ ‡
            touchStartX = e.touches[0].clientX;
        });

        cardScene.addEventListener('touchend', (e) => {
            // å¦‚æœå¤„äºè§£é”çŠ¶æ€ï¼ˆå¯ä»¥æ»šåŠ¨ï¼‰ï¼Œåˆ™ä¸è¿›è¡Œæ»‘åŠ¨åˆ‡æ¢ï¼Œé¿å…å†²çª
            if (isEditorUnlocked) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const deltaX = touchEndX - touchStartX;

            // åŠ¨ä½œå¹…åº¦ä¸å¤Ÿå¤§ï¼Œåˆ™è®¤ä¸ºæ˜¯ç‚¹å‡»ï¼ˆç¿»è½¬å¡ç‰‡ï¼‰æˆ–è¯¯è§¦ï¼Œä¸å¤„ç†æ»‘åŠ¨
            if (Math.abs(deltaX) < SWIPE_THRESHOLD) return; 

            // å¦‚æœå¡ç‰‡æ­£åœ¨ç¿»è½¬ï¼Œåˆ™ç­‰å¾…ç¿»è½¬å®Œæˆï¼Œä¸å¤„ç†æ»‘åŠ¨
            if (cardElement.classList.contains('is-flipped')) {
                // å…è®¸ç”¨æˆ·åœ¨ç¿»é¢æ—¶æ»‘åŠ¨ï¼Œä½†å…ˆè®©å¡ç‰‡å¤ä½
                cardElement.classList.remove('is-flipped');
                setTimeout(() => {
                    if (deltaX > 0) {
                        // å‘å³æ»‘åŠ¨ (Swipe Right) -> ä¸Šä¸€å¼ 
                        window.prevCard();
                    } else {
                        // å‘å·¦æ»‘åŠ¨ (Swipe Left) -> ä¸‹ä¸€å¼ 
                        window.nextCard();
                    }
                }, 200); // ç¨å¾®å»¶è¿Ÿï¼Œè®©ç”¨æˆ·æ„Ÿè§‰å¡ç‰‡ç¿»è½¬ååˆ‡æ¢äº†
            } else {
                if (deltaX > 0) {
                    // å‘å³æ»‘åŠ¨ (Swipe Right) -> ä¸Šä¸€å¼ 
                    window.prevCard();
                } else {
                    // å‘å·¦æ»‘åŠ¨ (Swipe Left) -> ä¸‹ä¸€å¼ 
                    window.nextCard();
                }
            }
        });


        initializeSpeech();
        loadDecks();
    </script>
</body>
</html>
