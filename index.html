<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">    
    <title>æˆ‘çš„å•è¯æœ¬</title>
    <style>
        /* ğŸ¨ æ ·å¼ä¿æŒä¸å˜ï¼šçº¯å‡€æµ…ç²‰è‰²ï¼Œè¾¹æ¡†åŠ ç²— */
        :root {
            --unified-pink: #ffc0cb; 
            --unified-pink-light: #fff5ee; 
            --bg-color: #fcfcfc; 
            --card-bg: #ffffff;
            --text-main: #333333; 
            --success-color: #66bb6a; 
            --warning-color: #ffa726; 
            --danger-color: #ef5350; 
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        /* æ ‡é¢˜å·²ä¿®æ”¹ */
        h1 { margin-bottom: 20px; font-size: 1.6rem; color: var(--unified-pink); } 

        .scene {
            width: 100%;
            max-width: 400px;
            height: 260px;
            perspective: 1000px;
            margin: 20px 0;
            cursor: pointer;
        }

        .card {
            width: 100%;
            height: 100%;
            position: relative;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            border-radius: 16px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.05);
        }

        .card.is-flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: var(--card-bg);
            border-radius: 16px;
            padding: 20px;
            box-sizing: border-box;
            border: 8px solid var(--unified-pink); 
        }

        .card-face.front { font-size: 2.5rem; font-weight: 700; color: var(--text-main); } 
        .card-face.back { 
            transform: rotateY(180deg); 
            background-color: var(--unified-pink-light); 
            font-size: 1.8rem; 
            color: var(--text-main); 
        }

        .hint { font-size: 0.8rem; color: #94a3b8; margin-top: 10px; position: absolute; bottom: 15px;}

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .btn-nav { background-color: white; border: 1px solid #cbd5e1; color: #475569; }
        .btn-nav:hover { background-color: #f0f0f0; }

        .btn-check { background-color: var(--unified-pink); color: white; } 
        .btn-check:hover { background-color: #ffb1c0; } 
        
        .btn-new-deck, .btn-add { background-color: var(--unified-pink); color: white; }
        .btn-new-deck:hover, .btn-add:hover { background-color: #ffb1c0; } 

        .btn-del { background-color: #ffe0e0; color: var(--danger-color); }
        .btn-warn { background-color: #fff8e1; color: var(--warning-color); border: 1px solid #ffcc80; } 
        .btn-warn:hover { background-color: #ffedc1; }
        
        /* æ¨¡æ€æ¡†å†…çš„æŒ‰é’® */
        .btn-modal-action { 
            padding: 5px 10px; 
            font-size: 0.85rem; 
            margin-left: 8px;
        }

        .deck-controls {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 400px;
            justify-content: flex-end;
            margin-bottom: 15px; 
        }
        /* æ–°å¢ï¼šä½¿ç¼–è¾‘æ§åˆ¶æŒ‰é’®åŒºåŸŸå¯ä»¥å®¹çº³æ›´å¤šæŒ‰é’® */
        .deck-controls-editor {
            display: flex;
            gap: 10px;
            flex-wrap: wrap; /* å…è®¸æŒ‰é’®æ¢è¡Œ */
            justify-content: flex-end;
            width: 100%;
            max-width: 400px;
            margin-top: 10px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
        }
        
        .typing-section {
            width: 100%;
            max-width: 400px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }

        #answerInput {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid var(--unified-pink); 
            border-radius: 6px;
        }
        .feedback {
            margin-top: 10px;
            font-weight: 600;
            height: 20px; 
            color: var(--danger-color);
        }
        
        input:focus {
            outline: none;
            border-color: var(--unified-pink); 
            box-shadow: 0 0 0 2px var(--unified-pink-light); 
        }

        .stats { margin-top: 10px; font-size: 0.9rem; color: #64748b; }
        
        /* === æ·»åŠ è¯æ±‡è¾“å…¥æ¡†æ ·å¼ === */
        .add-section input {
            width: 100%;
            padding: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            box-sizing: border-box; 
            margin-bottom: 10px;
        }
        
        /* === å•è¯åˆ—è¡¨æ¨¡æ€æ¡†æ ·å¼ === */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .word-list-modal {
            background: white;
            padding: 20px;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        .word-list-modal h3 {
            border-bottom: 2px solid var(--unified-pink);
            padding-bottom: 10px;
            margin-top: 0;
        }
        .word-list-modal ul {
            list-style: none;
            padding: 0;
        }
        /* åˆ—è¡¨é¡¹æ ·å¼è°ƒæ•´ï¼Œä»¥å®¹çº³æ“ä½œæŒ‰é’® */
        .word-list-modal li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px dotted #e2e8f0;
            font-size: 1rem;
            cursor: pointer; /* å¯ç”¨ç‚¹å‡»é€‰ä¸­æ•ˆæœ */
        }
        .word-info {
            flex-grow: 1;
        }
        .word-list-modal li strong {
            display: inline-block;
            min-width: 40px;
            color: var(--unified-pink);
            margin-right: 10px;
        }
        .word-actions {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .word-list-modal .close-btn {
            float: right;
            background: var(--danger-color);
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            position: absolute;
            top: 20px;
            right: 20px;
        }
        
    </style>
</head>
<body>

    <h1>ğŸ“ æˆ‘çš„å•è¯æœ¬</h1>
    
    <div style="width: 100%; max-width: 400px; text-align: right; margin-bottom: 5px;">
        <button id="muteButton" class="btn-warn" onclick="toggleMute()">ğŸ”‡ é™éŸ³</button>
    </div>

    <div style="margin-bottom: 10px; width: 100%; max-width: 400px; text-align: left;">
        <label for="cardDeckSelect" style="display: block; font-size: 0.9rem; color: #64748b; margin-bottom: 5px;">é€‰æ‹©å¡ç»„/åˆ†ç±»:</label>
        <select id="cardDeckSelect" onchange="switchDeck()" style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #cbd5e1;">
            </select>
    </div>
    
    <div class="deck-controls deck-controls-editor">
        <button id="unlockEditorButton" class="btn-check" onclick="unlockEditor()">ğŸ”‘ è§£é”ç¼–è¾‘</button>
        <button class="btn-nav editor-control" style="display: none;" onclick="viewAllWords()">ğŸ“– æŸ¥çœ‹æ‰€æœ‰å•è¯</button>
        <button class="btn-new-deck editor-control" style="display: none;" onclick="createNewDeck()">+ æ–°å¡ç»„</button>
        <button class="btn-warn editor-control" style="display: none;" onclick="deleteDeck()">- åˆ é™¤å¡ç»„</button>
    </div>
    
    <div class="stats">å½“å‰: <span id="currentIndex">0</span> / æ€»æ•°: <span id="totalCount">0</span></div>

    <div class="scene" onclick="flipCard()">
        <div class="card" id="flashcard">
            <div class="card-face front">
                <span id="displayFront">Loading...</span>
                <div class="hint">ç‚¹å‡»ç¿»çœ‹ç­”æ¡ˆ</div>
            </div>
            <div class="card-face back">
                <span id="displayBack">...</span>
            </div>
        </div>
    </div>
    
    <div class="typing-section">
        <h3>âŒ¨ï¸ æ‰“å­—æ¨¡å¼ (ä¸­æ–‡ -> æ—¥è¯­)</h3>
        <div class="typing-input-group">
            <input type="text" id="answerInput" placeholder="è¯·è¾“å…¥æ—¥è¯­ç­”æ¡ˆ (æŒ‰ Enter æäº¤)" onkeydown="if(event.key === 'Enter') checkAnswer()">
            <button class="btn-check" onclick="checkAnswer()">æ£€æŸ¥ç­”æ¡ˆ</button>
        </div>
        <div id="feedback" class="feedback"></div>
    </div>


    <div class="controls">
        <button class="btn-nav" onclick="prevCard()">â† ä¸Šä¸€ä¸ª</button>
        <button class="btn-del editor-control" style="display: none;" onclick="deleteCurrentCard()">åˆ é™¤è¿™å¼ </button>
        <button class="btn-nav" onclick="nextCard()">ä¸‹ä¸€ä¸ª â†’</button>
    </div>

    <hr style="width: 100%; max-width: 400px; border: 0; border-top: 1px solid #e2e8f0; margin-bottom: 20px;">

    <div class="add-section editor-control" style="display: none;">
        <h3>æ·»åŠ åˆ°å¡ç»„ï¼š<span id="currentDeckDisplay" style="color: var(--unified-pink);">æˆ‘çš„è‡ªåˆ›è¯æ±‡</span></h3>
        
        <input type="text" id="inputFront" placeholder="æ­£é¢ (ä¸­æ–‡è¯æ±‡/æ„æ€)">
        <input type="text" id="inputBack" placeholder="èƒŒé¢ (æ—¥è¯­/å‡å/ç½—é©¬éŸ³ï¼Œå¦‚ï¼šå…ˆç”Ÿï¼ˆã›ã‚“ã›ã„ï¼‰)">
        
        <div style="margin-top: 15px;"> 
            <button class="btn-add" onclick="addNewCard()" style="width: 100%;">æ·»åŠ å¹¶ä¿å­˜åˆ°å½“å‰å¡ç»„</button>
        </div>
    </div>

    <div id="wordListModal" class="modal-overlay" style="display: none;">
        <div class="word-list-modal">
            <button class="close-btn" onclick="closeWordList()">X å…³é—­</button>
            <h3 id="wordListTitle"></h3>
            
            <div id="moveActions" style="margin-bottom: 15px; padding: 10px; border: 1px solid var(--unified-pink-light); border-radius: 6px; display: none; background: #fff;">
                <label for="targetDeckSelect" style="font-size: 0.9rem; color: #64748b;">é€‰æ‹©ç›®æ ‡å¡ç»„:</label>
                <select id="targetDeckSelect" style="padding: 8px; border-radius: 6px; border: 1px solid #cbd5e1; width: 60%; margin-right: 10px;"></select>
                <button class="btn-check btn-modal-action" onclick="moveWordToDeck(this)">ğŸš€ ç§»åŠ¨é€‰ä¸­å•è¯</button>
            </div>
            
            <ul id="wordListContent">
                </ul>
        </div>
    </div>
    
    <script type="module">
        // å¯¼å…¥ Firebase SDK çš„æ ¸å¿ƒæ¨¡å—å’Œ Firestore æ¨¡å—
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";

        // ==========================================================
        // !!! æ‚¨çš„ä¸“å± Firebase é…ç½®å¯†é’¥ !!!
        // ==========================================================
        const firebaseConfig = {
            apiKey: "AIzaSyDRh1wj0UPt60ZDmVOKLc_qZ1FYE6J7TC",
            authDomain: "my-flashcard-sync.firebaseapp.com",
            projectId: "my-flashcard-sync",
            storageBucket: "my-flashcard-sync.appspot.com",
            messagingSenderId: "458534614208",
            appId: "1:458534614208:web:349f3c7a68cfed6f346925"
        };
        // ==========================================================
        
        // åˆå§‹åŒ– Firebase åº”ç”¨å’Œæ•°æ®åº“
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // è®¾å®šä¸€ä¸ªå›ºå®šçš„æ–‡æ¡£IDï¼Œç”¨äºå­˜å‚¨æ‚¨çš„æ‰€æœ‰æ•°æ®
        const USER_DOC_ID = 'RubyUserFlashcards'; 
        const USER_COLLECTION = 'user-decks'; 

        // --- åˆå§‹æ•°æ®ï¼Œç”¨äºäº‘ç«¯é¦–æ¬¡åŠ è½½æˆ–è¿æ¥å¤±è´¥æ—¶ä½¿ç”¨ ---
        const initialDecks = {
            'æˆ‘çš„è‡ªåˆ›è¯æ±‡': [
                { front: "æ—¥è¯­", back: "æ—¥æœ¬èªï¼ˆã«ã»ã‚“ã”ï¼‰" }, // ç¤ºä¾‹ä¸­åŠ å…¥æ‹¬å·
                { front: "è€å¸ˆ", back: "å…ˆç”Ÿï¼ˆã›ã‚“ã›ã„ï¼‰" },
                { front: "æˆ‘", back: "ç§ï¼ˆã‚ãŸã—ï¼‰" }
            ],
            'JLPT N5 åŸºç¡€': [
                { front: "æ—©ä¸Šå¥½", back: "ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™" },
                { front: "è°¢è°¢", back: "ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™" },
                { front: "äºº", back: "äººï¼ˆã²ã¨ï¼‰" }
            ]
        };

        // --- æ ¸å¿ƒçŠ¶æ€å˜é‡ ---
        let allDecks = {}; 
        let currentDeckName = 'æˆ‘çš„è‡ªåˆ›è¯æ±‡'; 
        let cards = []; 
        let currentIndex = 0;
        let isMuted = false;
        let japaneseVoice = null; 
        
        // !!! ğŸ”’ å¯†ç ä¿æŠ¤æ–°å¢å˜é‡ï¼šå·²ä¸ºæ‚¨æ›´æ–°ä¸º Japan !!!
        const EDITOR_PASSWORD = "Japan"; 
        let isEditorUnlocked = false; 

        // --- DOM å…ƒç´ å¼•ç”¨ ---
        const cardElement = document.getElementById('flashcard');
        const frontElement = document.getElementById('displayFront');
        const backElement = document.getElementById('displayBack');
        const deckSelect = document.getElementById('cardDeckSelect');
        const deckDisplay = document.getElementById('currentDeckDisplay');
        const answerInput = document.getElementById('answerInput');
        const feedbackElement = document.getElementById('feedback');
        
        // ====== è¯­éŸ³åˆå§‹åŒ– (è§£å†³å‘éŸ³é”™è¯¯çš„å…³é”®) ======
        
        function initializeSpeech() {
            if (!('speechSynthesis' in window)) return;
            
            const setVoice = () => {
                const voices = speechSynthesis.getVoices();
                japaneseVoice = voices.find(voice => 
                    voice.lang === 'ja-JP' && 
                    (voice.name.includes('Google') || voice.name.includes('Kyoko') || voice.name.includes('Haruka'))
                );

                if (!japaneseVoice) {
                    japaneseVoice = voices.find(voice => voice.lang === 'ja-JP');
                }
                
                if (japaneseVoice) {
                    console.log("å·²åŠ è½½æ—¥è¯­å£°æº:", japaneseVoice.name);
                }
                
                speechSynthesis.onvoiceschanged = null; 
            };

            if (speechSynthesis.getVoices().length) {
                setVoice();
            } else {
                speechSynthesis.onvoiceschanged = setVoice;
            }
        }


        // ====== å¯†ç æ§åˆ¶å‡½æ•° ======

        /**
         * æ§åˆ¶ç¼–è¾‘åŠŸèƒ½ UI çš„æ˜¾ç¤º/éšè—
         */
        function updateEditorUI() {
            const isLocked = !isEditorUnlocked;
            
            // 1. éšè—/æ˜¾ç¤ºæ‰€æœ‰æ ‡è®°ä¸º 'editor-control' çš„å…ƒç´ 
            document.querySelectorAll('.editor-control').forEach(el => {
                el.style.display = isLocked ? 'none' : '';
            });
            
            // 2. åˆ‡æ¢è§£é”æŒ‰é’®çš„æ˜¾ç¤º
            const unlockButton = document.getElementById('unlockEditorButton');
            if(unlockButton) {
                unlockButton.style.display = isLocked ? '' : 'none';
            }
        }
        
        /**
         * æç¤ºç”¨æˆ·è¾“å…¥å¯†ç å¹¶è§£é”ç¼–è¾‘åŠŸèƒ½
         */
        window.unlockEditor = function() {
            if (isEditorUnlocked) {
                alert("ç¼–è¾‘åŠŸèƒ½å·²è§£é”ã€‚");
                return;
            }

            const inputPassword = prompt("è¯·è¾“å…¥ç¼–è¾‘å¯†ç ä»¥è§£é”åŠŸèƒ½ï¼š");

            if (inputPassword === EDITOR_PASSWORD) {
                isEditorUnlocked = true;
                updateEditorUI();
                alert("ç¼–è¾‘åŠŸèƒ½å·²æˆåŠŸè§£é”ï¼");
            } else if (inputPassword !== null && inputPassword !== "") {
                alert("å¯†ç é”™è¯¯ï¼Œç¼–è¾‘åŠŸèƒ½æœªè§£é”ã€‚");
            }
        }

        // ====== æ ¸å¿ƒåŠŸèƒ½å‡½æ•°ï¼šäº‘ç«¯ä¿å­˜ä¸åŠ è½½ ======

        async function saveDecks() {
            try {
                const docData = {
                    decks: allDecks,
                    currentDeck: currentDeckName,
                };
                await setDoc(doc(db, USER_COLLECTION, USER_DOC_ID), docData);
                console.log("æ•°æ®å·²æˆåŠŸä¿å­˜åˆ°äº‘ç«¯ã€‚");
            } catch (e) {
                console.error("ä¿å­˜åˆ°äº‘ç«¯å¤±è´¥:", e);
                document.getElementById('feedback').innerText = "âŒ è­¦å‘Šï¼šåŒæ­¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œï¼";
            }
            updateUI();
        }

        async function loadDecks() {
            try {
                const docRef = doc(db, USER_COLLECTION, USER_DOC_ID);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    allDecks = data.decks || initialDecks;
                    currentDeckName = data.currentDeck || Object.keys(allDecks)[0];
                    currentIndex = 0; 
                    console.log("æ•°æ®å·²ä»äº‘ç«¯åŠ è½½ã€‚");
                } else {
                    allDecks = initialDecks;
                    currentDeckName = Object.keys(allDecks)[0];
                    console.log("äº‘ç«¯æ•°æ®ä¸ºç©ºï¼Œä½¿ç”¨åˆå§‹æ•°æ®å¹¶å°è¯•åŒæ­¥ã€‚");
                    await saveDecks(); 
                }
            } catch (e) {
                console.error("åŠ è½½äº‘ç«¯æ•°æ®å¤±è´¥:", e);
                allDecks = initialDecks;
                currentDeckName = Object.keys(allDecks)[0];
                alert("â— é”™è¯¯ï¼šæ— æ³•è¿æ¥åˆ°äº‘æ•°æ®åº“ï¼æ­£åœ¨ä½¿ç”¨æœ¬åœ°é»˜è®¤æ•°æ®ã€‚");
            }
            
            populateDeckSelect();
            switchDeck(currentDeckName, false); 
            updateEditorUI(); 
        }

        // ====== å¯¼èˆªä¸ UI æ›´æ–° (åŒ…å«éšæœºåŒ–é€»è¾‘) ======

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        window.updateUI = function() {
            const displayCards = cards.length === 0 ? [{front: `å¡ç»„ã€${currentDeckName}ã€‘`, back: "å¡ç‰‡ä¸ºç©ºï¼Œè¯·åœ¨ä¸‹æ–¹æ·»åŠ "}] : cards;
            
            currentIndex = Math.max(0, Math.min(currentIndex, cards.length - 1));
            
            document.getElementById('totalCount').innerText = cards.length;
            document.getElementById('currentIndex').innerText = cards.length === 0 ? 0 : currentIndex + 1;
            
            deckDisplay.innerText = currentDeckName; 
            feedbackElement.innerText = ''; 
            answerInput.value = ''; 

            if (cardElement.classList.contains('is-flipped')) {
                cardElement.classList.remove('is-flipped');
                setTimeout(() => setCardText(displayCards), 250);
            } else {
                setCardText(displayCards);
            }
            
            populateDeckSelect(); 
        }

        function setCardText(displayCards) {
            const actualIndex = Math.min(currentIndex, displayCards.length - 1);
            const currentCard = displayCards[actualIndex];
            
            frontElement.innerText = currentCard.front;
            // å¡ç‰‡èƒŒé¢ç°åœ¨æ˜¾ç¤ºå®Œæ•´å†…å®¹ï¼ŒåŒ…æ‹¬æ‹¬å·
            backElement.innerText = currentCard.back; 
        }

        window.flipCard = function() {
            cardElement.classList.toggle('is-flipped');
            const card = cards.length > 0 ? cards[currentIndex] : {front: "", back: "è¯·æ·»åŠ å¡ç‰‡"};
            
            if(cardElement.classList.contains('is-flipped')) {
                // æœ—è¯»æ—¶æ¸…é™¤æ‹¬å·å†…å®¹
                const textToRead = card.back.replace(/\s*\(.*\)/g, '').trim(); 
                readText(textToRead, 'ja-JP'); 
            } 
        }
        
        // ====== æ ¸å¿ƒç¼–è¾‘/ç®¡ç†å‡½æ•° ======

        window.addNewCard = async function() {
            if (!isEditorUnlocked) {
                alert("è¯·å…ˆç‚¹å‡»ã€è§£é”ç¼–è¾‘ã€‘æŒ‰é’®å¹¶è¾“å…¥å¯†ç ã€‚");
                return;
            }

            const f = document.getElementById('inputFront').value.trim();
            const b = document.getElementById('inputBack').value.trim();
            
            if (!f || !b) {
                alert("âš ï¸ é”™è¯¯æç¤ºï¼šæ­£é¢å’ŒèƒŒé¢éƒ½è¦å†™å“¦ï¼");
                return;
            }

            if (allDecks[currentDeckName]) {
                allDecks[currentDeckName].push({ front: f, back: b });
            } else {
                allDecks[currentDeckName] = [{ front: f, back: b }];
            }
            
            document.getElementById('inputFront').value = '';
            document.getElementById('inputBack').value = '';
            
            await saveDecks(); 
            switchDeck(currentDeckName, false);
        }

        window.deleteCurrentCard = async function() {
            if (!isEditorUnlocked) {
                alert("è¯·å…ˆç‚¹å‡»ã€è§£é”ç¼–è¾‘ã€‘æŒ‰é’®å¹¶è¾“å…¥å¯†ç ã€‚");
                return;
            }

            if(cards.length === 0 || cards[currentIndex].front.includes('å¡ç»„ã€')) {
                alert("å½“å‰å¡ç»„ä¸­æ²¡æœ‰å¯åˆ é™¤çš„å•è¯ï¼");
                return;
            }
            
            if(currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') {
                alert("è¯·åˆ‡æ¢åˆ°å…·ä½“çš„å¡ç»„è¿›è¡Œåˆ é™¤æ“ä½œï¼Œ'æ‰€æœ‰å¡ç‰‡'æ¨¡å¼ä¸‹æ— æ³•åˆ é™¤ã€‚");
                return;
            }

            if(confirm(`ç¡®å®šè¦ä»ã€${currentDeckName}ã€‘ä¸­åˆ é™¤è¿™å¼ å¡ç‰‡å—ï¼Ÿ`)) {
                
                const cardToDelete = cards[currentIndex];
                const originalDeck = allDecks[currentDeckName];
                
                const originalIndex = originalDeck.findIndex(card => 
                    card.front === cardToDelete.front && card.back === cardToDelete.back
                );

                if (originalIndex > -1) {
                     originalDeck.splice(originalIndex, 1);
                }
                
                await saveDecks(); 
                switchDeck(currentDeckName, false);
            }
        }
        
        // --- æ¨¡æ€æ¡†å†…çš„åˆ é™¤åŠŸèƒ½ ---
        window.deleteWordFromList = async function(buttonElement) {
            if (!isEditorUnlocked) return;
            
            const li = buttonElement.closest('li');
            const indexToDelete = parseInt(li.dataset.index);
            
            if (currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') {
                alert("è¯·åˆ‡æ¢åˆ°å…·ä½“çš„å¡ç»„è¿›è¡Œåˆ é™¤æ“ä½œã€‚");
                return;
            }

            if(confirm(`ç¡®å®šè¦åˆ é™¤ã€${allDecks[currentDeckName][indexToDelete].front}ã€‘è¿™å¼ å¡ç‰‡å—ï¼Ÿ`)) {
                allDecks[currentDeckName].splice(indexToDelete, 1);
                
                await saveDecks();
                // é‡æ–°æ¸²æŸ“åˆ—è¡¨ï¼Œä¿è¯ç´¢å¼•æ­£ç¡®
                viewAllWords(false); 
            }
        }
        
        // --- æ¨¡æ€æ¡†å†…çš„è½¬ç§»åŠŸèƒ½ ---
        window.moveWordToDeck = async function(buttonElement) {
            if (!isEditorUnlocked) return;
            
            const targetDeckSelect = document.getElementById('targetDeckSelect');
            const targetDeckName = targetDeckSelect.value;
            
            if (!targetDeckName || targetDeckName === currentDeckName) {
                alert("è¯·é€‰æ‹©ä¸€ä¸ªä¸åŒäºå½“å‰å¡ç»„çš„ç›®æ ‡å¡ç»„ã€‚");
                return;
            }
            
            const cardsToMove = [];
            const listItems = document.querySelectorAll('#wordListContent li');
            
            // æ”¶é›†æ‰€æœ‰è¢«é€‰ä¸­çš„å¡ç‰‡çš„ç´¢å¼•
            const selectedIndices = [];
            listItems.forEach((li, index) => {
                if (li.dataset.selected === 'true') {
                    selectedIndices.push(index);
                }
            });

            if (selectedIndices.length === 0) {
                alert("è¯·å…ˆç‚¹å‡»åˆ—è¡¨ä¸­çš„å•è¯æ¥é€‰æ‹©è¦ç§»åŠ¨çš„å¡ç‰‡ã€‚");
                return;
            }

            if (confirm(`ç¡®å®šå°†é€‰ä¸­çš„ ${selectedIndices.length} å¼ å¡ç‰‡ç§»åŠ¨åˆ°ã€${targetDeckName}ã€‘å—ï¼Ÿ`)) {
                
                // 1. ä»å½“å‰å¡ç»„ä¸­æ”¶é›†å¹¶ç§»é™¤å¡ç‰‡ (ä»åå¾€å‰ç§»é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–)
                const currentDeck = allDecks[currentDeckName];
                // æ’åºï¼Œä»å¤§åˆ°å°ç§»é™¤
                selectedIndices.sort((a, b) => b - a).forEach(index => {
                    cardsToMove.push(currentDeck[index]);
                    currentDeck.splice(index, 1);
                });
                
                // 2. æ·»åŠ åˆ°ç›®æ ‡å¡ç»„
                allDecks[targetDeckName] = allDecks[targetDeckName].concat(cardsToMove);
                
                await saveDecks();
                
                // é‡æ–°æ¸²æŸ“åˆ—è¡¨ï¼Œå¹¶å…³é—­æ¨¡æ€æ¡†
                closeWordList(); 
            }
        }
        
        // --- æŸ¥çœ‹æ‰€æœ‰å•è¯åŠŸèƒ½ (å·²ä¿®å¤ç‚¹å‡»é€‰ä¸­é€»è¾‘) ---

        window.viewAllWords = function(showModal = true) {
            if (!isEditorUnlocked) {
                alert("è¯·å…ˆç‚¹å‡»ã€è§£é”ç¼–è¾‘ã€‘æŒ‰é’®å¹¶è¾“å…¥å¯†ç ã€‚");
                return;
            }
            
            if(currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') {
                alert("è¯·åˆ‡æ¢åˆ°å…·ä½“çš„å¡ç»„å†æŸ¥çœ‹ã€‚'æ‰€æœ‰å¡ç‰‡'æ¨¡å¼æ— æ³•ç¼–è¾‘ã€‚");
                return;
            }

            const listContent = document.getElementById('wordListContent');
            const titleElement = document.getElementById('wordListTitle');
            const currentDeckCards = allDecks[currentDeckName] || []; // ä½¿ç”¨åŸå§‹å¡ç»„æ•°æ®
            const moveActions = document.getElementById('moveActions');

            
            titleElement.innerText = `ã€${currentDeckName}ã€‘ä¸­çš„æ‰€æœ‰å•è¯ (${currentDeckCards.length})`;
            listContent.innerHTML = '';
            moveActions.style.display = 'block';

            // å¡«å……ç›®æ ‡å¡ç»„é€‰æ‹©å™¨
            const targetDeckSelect = document.getElementById('targetDeckSelect');
            targetDeckSelect.innerHTML = '';
            Object.keys(allDecks).sort().forEach(name => {
                if(name !== 'æ‰€æœ‰å¡ç‰‡ (éšæœº)' && name !== 'è¯·æ·»åŠ æ–°å¡ç»„' && name !== currentDeckName) {
                    const option = document.createElement('option');
                    option.value = name;
                    option.innerText = name;
                    targetDeckSelect.appendChild(option);
                }
            });
            
            if (currentDeckCards.length === 0) {
                listContent.innerHTML = '<li>è¯¥å¡ç»„ä¸ºç©ºã€‚</li>';
                moveActions.style.display = 'none';
            } else {
                currentDeckCards.forEach((card, index) => {
                    const li = document.createElement('li');
                    li.dataset.index = index; // å­˜å‚¨åŸå§‹ç´¢å¼•
                    li.dataset.selected = 'false'; // åˆå§‹æœªé€‰ä¸­
                    
                    // --- æ ¸å¿ƒä¿®å¤åŒºåŸŸ ---
                    li.onclick = function() {
                        // åˆ‡æ¢é€‰ä¸­çŠ¶æ€
                        const isSelected = this.dataset.selected === 'true';
                        this.dataset.selected = isSelected ? 'false' : 'true';
                        // ä½¿ç”¨æ­£ç¡®çš„ CSS å˜é‡å€¼ #fff5ee è¿›è¡ŒèƒŒæ™¯åˆ‡æ¢
                        this.style.backgroundColor = isSelected ? 'transparent' : '#fff5ee'; 
                    };
                    // --- ä¿®å¤ç»“æŸ ---
                    
                    const info = document.createElement('div');
                    info.className = 'word-info';
                    info.innerHTML = `<strong>${card.front}</strong>ï¼š${card.back}`;
                    
                    const actions = document.createElement('div');
                    actions.className = 'word-actions';
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'btn-del btn-modal-action';
                    deleteBtn.innerText = 'âŒ åˆ é™¤';
                    // ä½¿ç”¨ stopPropagation é˜»æ­¢ç‚¹å‡»æŒ‰é’®æ—¶è§¦å‘çˆ¶çº§ li çš„ç‚¹å‡»äº‹ä»¶
                    deleteBtn.onclick = (e) => { e.stopPropagation(); deleteWordFromList(deleteBtn); }; 
                    
                    actions.appendChild(deleteBtn);
                    
                    li.appendChild(info);
                    li.appendChild(actions);
                    listContent.appendChild(li);
                });
            }

            if (showModal) {
                 document.getElementById('wordListModal').style.display = 'flex'; // æ˜¾ç¤ºæ¨¡æ€æ¡†
            }
        }

        window.closeWordList = function() {
            document.getElementById('wordListModal').style.display = 'none'; // éšè—æ¨¡æ€æ¡†
        }
        
        // --- å…¶ä»–ç®¡ç†/å¯¼èˆªå‡½æ•° (ä¸å˜) ---

        window.createNewDeck = async function() {
            if (!isEditorUnlocked) {
                alert("è¯·å…ˆç‚¹å‡»ã€è§£é”ç¼–è¾‘ã€‘æŒ‰é’®å¹¶è¾“å…¥å¯†ç ã€‚");
                return;
            }

            const newName = prompt("è¯·è¾“å…¥æ–°å¡ç»„çš„åç§° (ä¾‹å¦‚: æ˜ŸæœŸ, å®¶å…·, N4è¯æ±‡):");
            if (newName && newName.trim() && !allDecks[newName.trim()]) {
                const trimmedName = newName.trim();
                allDecks[trimmedName] = [];
                currentDeckName = trimmedName;
                populateDeckSelect();
                await saveDecks();
                switchDeck(currentDeckName, false);
            } else if (newName) {
                alert("å¡ç»„åç§°æ— æ•ˆæˆ–å·²å­˜åœ¨ï¼");
            }
        }

        window.deleteDeck = async function() {
            if (!isEditorUnlocked) {
                alert("è¯·å…ˆç‚¹å‡»ã€è§£é”ç¼–è¾‘ã€‘æŒ‰é’®å¹¶è¾“å…¥å¯†ç ã€‚");
                return;
            }
            
            if(currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') {
                alert("è¯·å…ˆåˆ‡æ¢åˆ°å…·ä½“çš„å¡ç»„å†è¿›è¡Œåˆ é™¤æ“ä½œã€‚");
                return;
            }

            const deckNames = Object.keys(allDecks);
            if (deckNames.length <= 1) {
                alert("è¿™æ˜¯æœ€åä¸€ä¸ªå¡ç»„ï¼Œä¸èƒ½åˆ é™¤ï¼è¯·æ‰‹åŠ¨åˆ é™¤å¡ç‰‡æˆ–æ–°å»ºå¡ç»„åå†åˆ é™¤ã€‚");
                return;
            }
            if (confirm(`âš ï¸ ç¡®å®šè¦åˆ é™¤æ•´ä¸ªå¡ç»„ã€${currentDeckName}ã€‘å—ï¼Ÿ\næ‰€æœ‰ ${allDecks[currentDeckName].length} å¼ å¡ç‰‡éƒ½å°†æ°¸ä¹…ä¸¢å¤±ï¼`)) {
                delete allDecks[currentDeckName];
                const remainingDeckNames = Object.keys(allDecks);
                currentDeckName = remainingDeckNames.find(name => name !== 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') || remainingDeckNames[0];
                await saveDecks();
                populateDeckSelect(); 
                switchDeck(currentDeckName, false);
            }
        }
        
        window.nextCard = async function() {
            if (cards.length === 0) return; 
            
            if (currentIndex < cards.length - 1) {
                currentIndex++;
            } else {
                currentIndex = 0; 
                if(currentDeckName !== 'è¯·æ·»åŠ æ–°å¡ç»„') {
                    switchDeck(currentDeckName, false);
                    return; 
                }
            }
            
            updateUI();
        }

        window.prevCard = async function() {
            if (cards.length === 0) return; 
            
            if (currentIndex > 0) {
                currentIndex--;
            } else {
                currentIndex = cards.length - 1; 
                if(currentDeckName !== 'è¯·æ·»åŠ æ–°å¡ç»„') {
                    switchDeck(currentDeckName, false);
                    return;
                }
            }
            
            updateUI();
        }
        
        function populateDeckSelect() {
            deckSelect.innerHTML = '';
            const deckNames = Object.keys(allDecks).sort();
            
            if (deckNames.length === 0) {
                 deckNames.push("è¯·æ·»åŠ æ–°å¡ç»„");
                 allDecks["è¯·æ·»åŠ æ–°å¡ç»„"] = [];
            }
            
            const totalCount = deckNames.reduce((sum, name) => {
                if(name !== 'è¯·æ·»åŠ æ–°å¡ç»„') return sum + allDecks[name].length;
                return sum;
            }, 0);
            
            const allOption = document.createElement('option');
            allOption.value = 'æ‰€æœ‰å¡ç‰‡ (éšæœº)';
            allOption.innerText = `æ‰€æœ‰å¡ç‰‡ (æ€»æ•°: ${totalCount})`;
            deckSelect.appendChild(allOption);

            deckNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.innerText = `${name} (${allDecks[name].length})`;
                deckSelect.appendChild(option);
            });
            
            deckSelect.value = currentDeckName;
        }
        
        window.switchDeck = async function(deckName = deckSelect.value, shouldSave = true) {
            currentDeckName = deckName;
            
            if (currentDeckName === 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') {
                let allCards = [];
                Object.keys(allDecks).forEach(deck => {
                    if (deck !== 'è¯·æ·»åŠ æ–°å¡ç»„') {
                         allCards = allCards.concat(allDecks[deck]);
                    }
                });
                cards = allCards;
            } else {
                cards = allDecks[currentDeckName] || [];
            }
            
            if (cards.length > 0) {
                cards = shuffleArray([...cards]); 
            }

            currentIndex = 0; 
            
            if(cards.length === 0) {
                cards = [{front: `å¡ç»„ã€${currentDeckName}ã€‘`, back: "å¡ç‰‡ä¸ºç©ºï¼Œè¯·åœ¨ä¸‹æ–¹æ·»åŠ "}];
            }
            
            if (shouldSave && currentDeckName !== 'æ‰€æœ‰å¡ç‰‡ (éšæœº)') await saveDecks(); 
            else updateUI();
        }

        // ====== è¯­éŸ³å’Œç­”æ¡ˆæ£€æŸ¥åŠŸèƒ½ ======

        // é™éŸ³åˆ‡æ¢å‡½æ•°
        window.toggleMute = function() {
            isMuted = !isMuted;
            const button = document.getElementById('muteButton');
            
            if (isMuted) {
                button.innerHTML = 'ğŸ”Š å¼€å¯å£°éŸ³';
                button.classList.remove('btn-warn');
                button.classList.add('btn-nav'); 
            } else {
                button.innerHTML = 'ğŸ”‡ é™éŸ³';
                button.classList.remove('btn-nav');
                button.classList.add('btn-warn'); 
            }
        }
        
        function readText(text, lang) {
            if (lang === 'zh-CN' || isMuted || !('speechSynthesis' in window)) {
                return;
            }
            
            if (lang === 'ja-JP') {
                speechSynthesis.cancel(); 
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = lang; 
                
                if (japaneseVoice) {
                    utterance.voice = japaneseVoice;
                } else {
                     utterance.rate = 0.8;
                }
                
                speechSynthesis.speak(utterance);
            }
        }
        
        window.checkAnswer = function() {
            if (cards.length === 0 || cards[currentIndex].front.includes('å¡ç»„ã€')) {
                feedbackElement.innerText = "è¯·å…ˆæ·»åŠ å¡ç‰‡ï¼";
                return;
            }

            const card = cards[currentIndex];
            const actual = answerInput.value.toLowerCase().trim();
            const backContent = card.back.toLowerCase().trim(); // ä¿æŒå®Œæ•´å†…å®¹

            let acceptableAnswers = [];
            const regex = /(.+)\s*[ï¼ˆ(](\S+)[)ï¼‰]/; // åŒ¹é… "base (reading)" æ ¼å¼
            const match = backContent.match(regex);
            
            if (match) {
                // æ¥å—æ±‰å­—å’Œå‡åä¸¤ç§ç­”æ¡ˆ
                const kanji = match[1].trim(); 
                const kana = match[2].trim(); 
                acceptableAnswers.push(kanji);
                acceptableAnswers.push(kana);
            } else {
                // å¦‚æœæ²¡æœ‰æ‹¬å·ï¼Œåˆ™æ•´ä¸ªèƒŒé¢å†…å®¹éƒ½æ˜¯ç­”æ¡ˆ
                acceptableAnswers.push(backContent);
            }

            if (acceptableAnswers.includes(actual)) {
                feedbackElement.innerText = "ğŸ‰ æ­£ç¡®ï¼";
                feedbackElement.style.color = 'var(--success-color)';
                
                setTimeout(() => {
                    window.nextCard(); 
                }, 700);
                
            } else {
                // åœ¨åé¦ˆä¸­æ˜¾ç¤ºæ‰€æœ‰å¯æ¥å—çš„ç­”æ¡ˆï¼Œå¸®åŠ©ç”¨æˆ·ç†è§£
                feedbackElement.innerText = `âŒ é”™è¯¯ã€‚ç­”æ¡ˆå¯ä»¥æ˜¯: ${acceptableAnswers.join(' æˆ– ')}ã€‚`;
                feedbackElement.style.color = 'var(--danger-color)';
            }
        }

        // å¯åŠ¨ï¼
        initializeSpeech();
        loadDecks();
    </script>
</body>
</html>
